import json
from dataclasses import dataclass
from typing import Literal

from defi_risk_analyzer.analysis.static_analysis import analyze_source


ExpectedCategory = Literal[
    "reentrancy",
    "missing_access_control",
    "unsafe_external_calls",
    "broken_accounting",
]


@dataclass(frozen=True)
class ExpectedRedFlag:
    # Ground-truth label used only for evaluation.
    category: ExpectedCategory
    description: str


@dataclass(frozen=True)
class ExploitEvaluationResult:
    # Evaluation output: detected vs missed expected issues.
    detected: list[ExpectedRedFlag]
    missed: list[ExpectedRedFlag]
    detected_ids: list[str]


EXPECTED_TO_RULE_IDS: dict[ExpectedCategory, set[str]] = {
    "reentrancy": {"source:missing-nonreentrant"},
    "missing_access_control": {"source:missing-onlyowner"},
    "unsafe_external_calls": {"source:delegatecall", "source:call.value"},
    "broken_accounting": set(),
}


def load_expected_flags(path: str) -> list[ExpectedRedFlag]:
    # Load expected categories for a given fixture.
    with open(path, "r", encoding="utf-8") as handle:
        payload = json.load(handle)
    expected: list[ExpectedRedFlag] = []
    for item in payload:
        expected.append(
            ExpectedRedFlag(
                category=item["category"],
                description=item.get("description", ""),
            )
        )
    return expected


def evaluate_exploit_contract(
    source_code: str,
    expected: list[ExpectedRedFlag],
) -> ExploitEvaluationResult:
    # Compare analyzer detections with expected categories.
    detected_flags = analyze_source(source_code)
    detected_ids = [flag.id for flag in detected_flags]

    detected: list[ExpectedRedFlag] = []
    missed: list[ExpectedRedFlag] = []
    for item in expected:
        rule_ids = EXPECTED_TO_RULE_IDS.get(item.category, set())
        if rule_ids and any(rule_id in detected_ids for rule_id in rule_ids):
            detected.append(item)
        else:
            missed.append(item)

    return ExploitEvaluationResult(
        detected=detected,
        missed=missed,
        detected_ids=detected_ids,
    )


def generate_exploit_report(result: ExploitEvaluationResult) -> str:
    # Simple Markdown summary for exploit evaluation runs.
    lines = [
        "# Exploit Evaluation",
        "",
        "## Detected expected issues",
    ]
    if not result.detected:
        lines.append("- None")
    else:
        for item in result.detected:
            lines.append(f"- **{item.category}** — {item.description}")

    lines.extend(["", "## Missed expected issues"])
    if not result.missed:
        lines.append("- None")
    else:
        for item in result.missed:
            lines.append(f"- **{item.category}** — {item.description}")

    lines.extend(["", "## Raw detected rule IDs"])
    for rule_id in result.detected_ids:
        lines.append(f"- `{rule_id}`")

    return "\n".join(lines)
